<!DOCTYPE html>
<html>
<head>
<script src="https://unpkg.com/@metamask/detect-provider/dist/detect-provider.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js@3.0.0/dist/web3.min.js"></script>
<script src="config.js" ></script>
<link rel="stylesheet" href="./style_mintpage.css">

</head>
<body>

<button class="connectButton" visibility='hidden' onclick=connectAccount()>Connect MetaMask</button>
<div><p><span class="info"></span></p></div>

<!--<div class=artistName> <p class="artistFirstName">Herv&eacute; </p>  <p class="artistLastName"> Di Rosa </p></div>-->
<div class='artistImage'><img class='imgArtist' src='./herve.png' /></div>
<div id="tokens" />

<script type="text/javascript">
var web3 = new Web3(window.ethereum);
var collections = {};
var MetagencyForSale = null;

const metagencyForSaleAddress = config.saleContractAddress;

var tokensDiv = document.getElementById("tokens");
const connectButton = document.querySelector('.connectButton');
const info = document.querySelector('.info');
const artistImage = document.querySelector('.artistImage');

async function connectAccount(){
	await ethereum.request({ method: 'eth_requestAccounts' }).then((accounts) => {
	    if (!checkChain(ethereum.chainId)){
		wrongChain()
	    } else {
		if (accounts){
		    // is connected
		    console.log('connected')
		    connectButton.style.visibility = 'hidden';

			if (ethereum.chainId == config.chain ) {

				console.log('fetching collections')
				initEverything().then(() => {
				  getAvailableTokens();
				});

			}


		} else{
		    connectButton.style.visibility = 'visible';

		}

	    }
	}).catch((err) => {
	    if (err.code === 4001) {
	    // EIP-1193 userRejectedRequest error
	    // If this happens, the user rejected the connection request.
		console.error('User rejected connection request!');
	    } else {
		console.error(err);
	    }
	});
}

function wrongChain(){
	info.innerHTML = "Please change Chain to " + config.chainName + "!";
	connectButton.style.visibility = 'hidden';
        artistImage.style.visibility = 'hidden';
	console.log('wrong Chain')
}

function checkChain(chainId){
	if (chainId === config.chain){
	    return true;
	} else{
	    return false;
	}
}

function accountsChanged(){
	console.log('account changed')
	window.location.reload()
}




if (window.ethereum && ethereum.isMetaMask){

	ethereum.on('disconnect', (error) => window.location.reload());
	ethereum.on('chainChanged', (_chainId) => window.location.reload());
	ethereum.on('accountsChanged', (_) => accountsChanged);
	ethereum.on('connect', (connectInfo) => {
	    // is on correct chain
	    if (!checkChain(connectInfo.chainId)){
		wrongChain()
	    }


	if (connectInfo.chainId == config.chain ) {

		console.log('fetching collections')
		initEverything().then(() => {
		  getAvailableTokens();
		});

	}


	});

	ethereum.on('message', (message) =>
	    console.log(message)
	);
	connectAccount();
} else{
	console.log('Please Install MetaMask')
	info.innerHTML = 'Please install MetaMask!';
	connectButton.style.visibility = 'hidden';
        artistImage.style.visibility = 'hidden';
}


async function initEverything() {


 // TODO FIX this only fetches collection when on right chain at the moment
  const response2 = await fetch("./ForTheLolzForSale.json");
  const contract_abi2 = await response2.json();
  MetagencyForSale = new web3.eth.Contract(
      contract_abi2.abi, metagencyForSaleAddress);

  const response = await fetch("./ForTheLolzItem.json");
  const contract_abi = await response.json();

  const metagencyCollections = await MetagencyForSale.methods.getCollections().call();
  metagencyCollections.forEach(collectionAddress => {
    const metagencyCollection = new web3.eth.Contract(
        contract_abi.abi, collectionAddress);
    collections[metagencyCollection._address] = metagencyCollection;
  });



}

function ipfsToHttpsUrl(tokenURI) {
  let ipfsUrl = tokenURI.replace('ipfs://', '');
  if (!ipfsUrl.startsWith('ipfs/')) {
    ipfsUrl = `ipfs/${ipfsUrl}`;
  }
  return `https://ipfs.io/${ipfsUrl}`;
}

async function getTokenDiv(collection, tokenId, tokenURI, price, availableItems, totalItemsForSale) {
  const ipfsUrl = ipfsToHttpsUrl(tokenURI);

  const response = await fetch(ipfsUrl);
  const text = await response.json();
  const image = ipfsToHttpsUrl(text.image);
  const name = text.name;
  const description = text.description;
  const priceETH = web3.utils.fromWei(price);
  var div = document.createElement('div');
  div.setAttribute("class", "item");

  var disabled = "";
  if (availableItems == 0){ disabled = "disabled" } else{ disabled = ""}
  var button  = `<button ${disabled} onclick="buyToken('${collection}', ${tokenId}, ${price})">MINT</button>`
  div.innerHTML = `<div class='imgDiv'><img class='imgNFT' src="${image}"/></div>`
  div.innerHTML += `<div class="nameDiv">${name}</div>`
  if (description){
  	div.innerHTML += `<div>${description}</div>`
	}


  if (availableItems == 0){
  	div.innerHTML += `<div class="available">SOLD OUT</div>`
  }else{
  	div.innerHTML += `<div class="available">${availableItems} / ${totalItemsForSale} </div>`
  }
  div.innerHTML += `<div class='bottomElement'><div class='price'>${priceETH}</div><div class='ETH'>ETH</div><div class='mintButton'>${button}</div></div> `

  //div.innerHTML = `${name}, ${description}, <img height="80" src="${image}"/>, ${priceETH} ETH, ${availableItems} / ${totalItemsForSale} <button onclick="buyToken('${collection}', ${tokenId}, ${price})">MINT</button> <br>`;


  return div;
}

async function buyToken(collectionAddress, toBuyTokenId, priceInWei) {
  await collections[collectionAddress].methods.buyToken(toBuyTokenId)
      .send({from: ethereum.selectedAddress, value: priceInWei});
}

async function getTotalNumberOfArtworks() {
  const totalNumberOfArtworks = (await MetagencyForSale.methods
    .getTotalNumberOfArtworks().call()).map((num) => parseInt(num));
  return totalNumberOfArtworks;
}

async function getAvailableTokens() {
  const totalNumberOfArtworks = await getTotalNumberOfArtworks();
  const balanceOfOwner = await MetagencyForSale.methods
    .balanceOf(metagencyForSaleAddress).call();
  for (var i = 0; i < balanceOfOwner; i++) {
    const tokenId = await MetagencyForSale.methods
      .tokenOfOwnerByIndex(metagencyForSaleAddress, i).call();
    /* TODO: later check collection */

    const tokenURI = await MetagencyForSale.methods
      .tokenURI(tokenId).call();
    const price = await MetagencyForSale.methods
      .getTokenPrice(tokenId).call();
    const totalItemsForSale = totalNumberOfArtworks[tokenId];
    const availableItems = await MetagencyForSale.methods
      .getAvailableNumberOfArtworks(tokenId).call();
    const collection = await MetagencyForSale.methods
      .getCollectionOfTokenId(tokenId).call();
    const tokenDiv = await getTokenDiv(
        collection, tokenId, tokenURI, price, availableItems, totalItemsForSale);
    tokensDiv.appendChild(tokenDiv);
  }
}




</script>
</body>
</html>
